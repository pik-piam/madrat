% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/toolFixWeight.R
\name{toolFixWeight}
\alias{toolFixWeight}
\title{toolFixWeight}
\usage{
toolFixWeight(weight, rel, from, to, dim)
}
\arguments{
\item{weight}{magclass object containing weights to be used for a weighted
(dis)aggregation. The provided weight does not need to be normalized, any
number >= 0 is allowed.}

\item{rel}{relation matrix, mapping or file containing a mapping in a format
supported by \code{\link{toolGetMapping}} (currently csv, rds or rda).
A mapping object consists of any number of columns, where one column contains
all the elements in x. These elements are mapped to the corresponding values
in another column, as described below (see parameter 'from').
It is possible to not set \code{rel} as long as \code{to} is set and \code{dim}
is chosen appropriately. In that case the relation mapping is extracted from
the dimnames of the corresponding dimension, e.g. if your data contains a
spatial subdimension "country" you can aggregate to countries via
\code{toolAggregate(x, to = "country", dim = 1)}.}

\item{from}{Name of source column to be used in rel if it is a
mapping (if not set the first column matching the data will be used).}

\item{to}{Name of the target column to be used in rel if it is a
mapping (if not set the column following column \code{from} will be used
If column \code{from} is the last column, the column before \code{from is
used}). If data should be aggregated based on more than one column these
columns can be specified via "+", e.g. "region+global" if the data should
be aggregated to column regional as well as column global.
If \code{rel} is missing \code{to} refers to the aggregation target dimension name.}

\item{dim}{Specifying the dimension of the magclass object that should be
(dis-)aggregated. Either specified as an integer
(1=spatial,2=temporal,3=data) or if you want to specify a sub dimension
specified by name of that dimension or position within the given dimension
(e.g. 3.2 means the 2nd data dimension, 3.8 means the 8th data dimension).}
}
\value{
weight, with weights set to 10^-30 only where otherwise the total
sum of the (dis)aggregated object would be different from the original
}
\description{
Check the example below for the problem this function is solving.
Instead of adding a small number (like 10^-10) to each entry in weight,
set only those weights to 10^-30 where otherwise the total sum of the
(dis)aggregated object would be different from the original.
}
\examples{
x <- new.magpie(c("A", "B"), fill = 100)
rel <- data.frame(from = c("A", "A", "B", "B"),
                  to = c("A1", "A2", "B1", "B2"))
weight <- new.magpie(c("A1", "A2", "B1", "B2"), fill = 0)
weight["B1", , ] <- 1

y <- toolAggregate(x, rel, weight) # warning "Weight sum is 0"
stopifnot(sum(x) - sum(y) == 100) # total sum no longer equal, hence the warning
stopifnot(as.vector(y["B2", , ]) == 0)

# problematic hotfix
y <- toolAggregate(x, rel, weight + 10^-10) # no warning
stopifnot(sum(x) == sum(y)) # total sum is equal
stopifnot(as.vector(y["B2", , ]) > 0) # this is the problem, should still be 0

# proper fix
y <- toolAggregate(x, rel, weight, zeroWeight = "fix") # no warning
stopifnot(sum(x) == sum(y)) # total sum is equal
stopifnot(as.vector(y["B2", , ]) == 0) # and this is also still 0

}
\seealso{
\code{\link{toolAggregate}}
}
\author{
Pascal Sauer
}
